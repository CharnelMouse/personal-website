---
title: "CAWS19 predictions"
output: 
  flexdashboard::flex_dashboard:
    navbar:
      - {title: "Main Codex page", href: "/project/codex", align: right}
      - {title: "Main site", href: "/", align: right}
    theme: bootstrap
    css: tables.css
author: "Mark Webster"
date: 2020-03-02
---

```{r, "setup", include=FALSE}
library(tidyverse)
theme_codex <- theme_dark() +
  theme(panel.border = element_rect(fill = NA, colour = "grey13"),
        plot.background = element_rect(fill = "grey13", colour = "grey13"),
        axis.ticks = element_line(colour = "white"),
        strip.background = element_rect(fill = "grey13", colour = NA),
        legend.background = element_rect(fill = "grey13", colour = NA),
        text = element_text(colour = "white"),
        axis.text = element_text(colour = "white"), 
  )
theme_set(theme_codex)
library(magrittr)
library(data.table)
library(codex)
library(DT)
library(lpSolve)
library(knitr)
library(plotly)
knitr::opts_chunk$set(echo = FALSE)
```

```{r, "DT function to fill containers with single page"}
DT_fill <- function(df, dom_filter = FALSE) {
  datatable(df, rownames = FALSE, filter = "top", fillContainer = TRUE,
            options = list(dom = ifelse(dom_filter, "fti", "ti"), pageLength = nrow(df)))
}
```

```{r, "read model results"}
vs_results <- readRDS("tidy_vs_split.rds")
```

# Entrants {data-navmenu="Data"}

```{r, "CAWS19 matchups"}
caws_players <- c("FrozenStorm", "charnel_mouse", 
                  "CarpeGuitarrem", 
                  "zhavier", "Nopethebard", "Akiata", 
                  "Bomber678", "bolyarich", "dwarddd", "EricF", 
                  "codexnewb")
caws_decks <- standardise_deck_name(c("[Future]/Peace/Necromancy", "[Balance]/Blood/Strength", 
                                      "[Necromancy]/Blood/Present", 
                                      "[Balance]/Growth/Finesse", "MonoRed", "[Past]/Peace/Anarchy", 
                                      "MonoRed", "Nightmare", "[Past/Present]/Peace", "[Feral]/Law/Fire", 
                                      "Miracle Grow"), 
                                    codex::starters, codex::nicknames)
caws_entries <- data.table(player = caws_players, deck = caws_decks, stringsAsFactors = TRUE)
kable(caws_entries)
caws_valid <- !is.na(caws_decks)
```

# Completed matches {data-navmenu="Data"}

```{r, "CAWS19 matches"}
CAWS19_matches <- fread("CAWS19.csv", colClasses = list(Date = c("start", "end")))
```


```{r, "finished CAWS matches"}
finished_CAWS19_matches <- CAWS19_matches[!is.na(victor)]
DT_fill(finished_CAWS19_matches[, c("round", "player1", "player2", "deck1", "deck2", "victor")],
        dom_filter = TRUE)
```

# Matchup plots {data-orientation=rows data-navmenu="Predictions" .no-mobile}

Colours indicate mean matchup, using the [viridis inferno palette](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html). Vertical lines in each violin plot mark the inner quartiles. Rows are for Player 1, columns are for Player 2. (Currently not shown on mobile devices.)

```{r, "matchup plot with wrap function"}
plot_samples_wrap <- function(matchup_samples) {
  plot_matchup_samples(matchup_samples[, .(P1 = `levels<-`(P1, stringr::str_replace_all(levels(P1), "/", " ")),
                                                                               P2 = `levels<-`(P2, stringr::str_replace_all(levels(P2), "/", " ")),
                                                                               prob_matchup, prob_mean)], 2) +
  facet_grid(P1~P2, labeller = labeller(P1 = label_wrap_gen(10), P2 = label_wrap_gen(15)))
}
```

### Deck only

```{r, "CAWS19 lognormal deck matchup samples plot", fig.width=10.5, fig.height=7.5, warning=FALSE}
plot_samples_wrap(get_matchups(vs_results, caws_decks[caws_valid]))
```

### Overall

```{r, "CAWS19 overall matchup samples plot", fig.width=10.5, fig.height=7.5, warning=FALSE}
plot_matchup_samples(get_matchups(vs_results, caws_decks[caws_valid], caws_players[caws_valid]), 2)
```

# Matchup tables {data-orientation=rows data-navmenu="Predictions"}

```{r, "CAWS19 mean matchups"}
caws_deck_matchup_array <- get_matchup_array(vs_results, caws_decks[caws_valid])
caws_matchup_array <- get_matchup_array(vs_results, caws_decks[caws_valid], caws_players[caws_valid])

caws_deck_matchups <- apply(caws_deck_matchup_array, 2:3, mean)
caws_matchups <- apply(caws_matchup_array, 2:3, mean)
```

### Deck-only

```{r, "CAWS19 deck matchups"}
formatRound(DT_fill(reformat_mean_matchup(caws_deck_matchups, "D"), dom_filter = TRUE), 3:4, 3L)
```

### Overall

```{r, "CAWS19 overall matchups"}
formatRound(DT_fill(reformat_mean_matchup(caws_matchups, "P"), dom_filter = TRUE), 3:4, 3L)
```

# Nash equilibria for entrants {data-orientation=rows data-navmenu="Predictions"}

Nash equilibrium is not a good indicator of who's most likely to win the tournament, but it's a quick, simple heuristic to find likely contenders. Weights given are averaged over Nash equilibria calculated for each simulation sample (n = 4000).

```{r, "CAWS19 mean Nash"}
caws_deck_nash_samples <- get_nash_equilibria(caws_deck_matchup_array)
caws_deck_mean_nash <- as.data.table(apply(caws_deck_nash_samples, 1:2, mean), 
                                     keep.rownames = "Player")[, c(.(Player = factor(Player, 
                                                                                     c("P1", "P2", "Both"))), 
                                                                   .SD), 
                                                               .SDcols = dimnames(caws_deck_nash_samples)[[2]]]
caws_nash_samples <- get_nash_equilibria(caws_matchup_array)
caws_mean_nash <- as.data.table(apply(caws_nash_samples, 1:2, mean), 
                                keep.rownames = "Player")[, c(.(Player = factor(Player, 
                                                                                c("P1", "P2", "Both"))), 
                                                              .SD), 
                                                          .SDcols = dimnames(caws_nash_samples)[[2]]]
```

## Mean Nash win rate {data-height=300}

### Deck-only mean win rate

```{r, "deck mean Nash win"}
kable(print_nash(caws_deck_mean_nash), digits = 3)
```

### Overall mean win rate

```{r, "overall mean Nash win"}
kable(print_nash(caws_mean_nash), digits = 3)
```

## Mean Nash pick rate {data-height=700}

### Deck-only mean pick distribution

```{r, "deck mean Nash spread"}
kable(reformat_used_nash(caws_deck_mean_nash), digits = 3)
```

### Overall mean pick distribution

```{r, "overall mean Nash spread"}
kable(reformat_used_nash(caws_mean_nash), digits = 3)
```

# Tournament & evaluation {data-navmenu="Predictions"}

## Plots {data-width=400}

```{r, "CAWS19 matchup progression"}
caws_match_predictions <- CAWS19_matches[, .(round, round_match_number,
                                             player1, player2,
                                             deck1, deck2,
                                             victor = factor(ifelse(is.na(victor), "ongoing", ifelse(victor == player1, "P1", "P2")),
                                                             levels = c("P1", "P2", "ongoing")),
                                             `P1 win probability` = diag(caws_matchups[player1, player2]))
                                         ][, c(.SD, .(fairness = 1 - 2*abs(`P1 win probability` - 1/2)))]
```

###

```{r, "plot CAWS19 matchup progression"}
ggplotly(ggplot(caws_match_predictions,
                aes(x = round, y = `P1 win probability`, colour = victor,
                    text = paste0("round: ", round, "\nP1: ", paste(player1, deck1), "\nP2: ", paste(player2, deck2),
                                  "\nP1 win probability: ", round(`P1 win probability`, digits = 3),
                                  "\nfairness: ", round(fairness, digits = 3),
                                  "\nvictor: ",
                                  ifelse(victor == "P1", player1, ifelse(victor == "P2", player2, "ongoing"))))) +
           geom_point() +
           scale_colour_viridis_d(),
         tooltip = c("text"))
```

###

```{r, "plot CAWS19 fairness progression"}
ggplotly(ggplot(caws_match_predictions,
                aes(x = round, y = `fairness`, colour = victor,
                    text = paste0("round: ", round, "\nP1: ", paste(player1, deck1), "\nP2: ", paste(player2, deck2),
                                  "\nP1 win probability: ", round(`P1 win probability`, digits = 3),
                                  "\nfairness: ", round(fairness, digits = 3),
                                  "\nvictor: ",
                                  ifelse(victor == "P1", player1, ifelse(victor == "P2", player2, "ongoing"))))) +
           geom_point() +
           scale_colour_viridis_d(),
         tooltip = c("text"))
```

## Evaluation {data-width=600}

```{r, "CAWS19 counts"}
caws_matches_result_tallies <- finished_CAWS19_matches[, .(P1 = as.factor(player1),
                                                           P2 = as.factor(player2),
                                                           `P1 win` = victor == player1)
                                                       ]
caws_matches_counts <- caws_matches_result_tallies[, .(`P1 wins` = paste(sum(`P1 win`), .N, sep = "/")),
                                                   by = c("P1", "P2")]
```

```{r, "CAWS19 prediction evaluation"}
caws_matchups_table <- as.data.table(caws_matchups, keep.rownames = "P1")[, c(list(P1 = factor(P1, unique(P1))), .SD),
                                                                                      .SDcols = setdiff(colnames(caws_matchups), "P1")] %>% 
  melt(id.vars = "P1", variable.name = "P2", value.name = "matchup")
caws_lognormal_eval <- caws_matchups_table[caws_matches_counts, on = c("P1", "P2")
                                                ][order(P1, P2)]
```

### {data-height=200}

```{r, "CAWS19 scores"}
kable(caws_matchups_table[caws_matches_result_tallies, on = c("P1", "P2")
                          ][, .(`Brier score` = mean((`P1 win` - matchup)^2))
                            ][, .(forecast = c("always 5-5", "model"), `Brier score` = c(1/4, `Brier score`))],
      digits = 3)
```

### {data-height=800}

```{r, "CAWS19 evaluation table"}
formatRound(DT_fill(caws_lognormal_eval[order(-matchup)], dom_filter = TRUE), 3, 3)
```
