---
title: "CAWS20 predictions"
output: 
  flexdashboard::flex_dashboard:
    navbar:
      - {title: "Main Codex page", href: "/project/codex", align: right}
      - {title: "Main site", href: "/", align: right}
    theme: bootstrap
    css: tables.css
    self_contained: no
    lib_dir: libs
author: "Mark Webster"
date: 2020-01-30
---

```{r, "setup", include=FALSE}
current <- "CAWS20"
dropped_players = "EricF"
library(ggplot2)
theme_codex <- theme_dark() +
  theme(panel.border = element_rect(fill = NA, colour = "grey13"),
        plot.background = element_rect(fill = "grey13", colour = "grey13"),
        axis.ticks = element_line(colour = "white"),
        strip.background = element_rect(fill = "grey13", colour = NA),
        legend.background = element_rect(fill = "grey13", colour = NA),
        text = element_text(colour = "white"),
        axis.text = element_text(colour = "white"), 
  )
theme_set(theme_codex)
library(magrittr)
library(data.table)
library(codexdata)
library(codex)
library(lpSolve)
library(knitr)
library(plotly)
knitr::opts_chunk$set(echo = FALSE)
```

```{r, "read model results"}
vs_results <- readRDS("website_current_vs_split.rds")
```

# Entrants {data-navmenu="Data"}

```{r, "current matchups"}
current_players <- decks[tournament == current, player]
which_dropped <- match(dropped_players, current_players)
nondropped_players <- current_players[-which_dropped]
current_decks <- decks[tournament == current, deck]
nondropped_decks <- current_decks[-which_dropped]
current_entries <- data.table(player = current_players, deck = current_decks, stringsAsFactors = TRUE)
kable(current_entries)
current_valid <- !is.na(current_decks)
nondropped_valid <- !is.na(nondropped_decks)
```

# Completed matches {data-navmenu="Data"}

```{r, "current matches"}
current_matches <- matches[tournament == current][order(round, round_match_number)]
```

```{r, "finished current matches"}
finished_current_matches <- current_matches[!is.na(victor)]
kable(finished_current_matches[, c("round",
                                   "player1", "player2",
                                   "deck1", "deck2",
                                   "victor", "victory")],
      digits = 3)
```

# Matchup plots {data-orientation=rows data-navmenu="Predictions" .no-mobile}

Colours indicate mean matchup, using the [viridis inferno palette](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html). Vertical lines in each violin plot mark the inner quartiles. Rows are for Player 1, columns are for Player 2. (Currently not shown on mobile devices.)

```{r, "matchup plot with wrap function"}
plot_samples_wrap <- function(matchup_samples) {
  plot_matchup_samples(matchup_samples[, .(P1 = `levels<-`(P1, stringr::str_replace_all(levels(P1), "/", " ")),
                                           P2 = `levels<-`(P2, stringr::str_replace_all(levels(P2), "/", " ")),
                                           prob_matchup, prob_mean)], 2) +
    facet_grid(P1~P2, labeller = labeller(P1 = label_wrap_gen(10), P2 = label_wrap_gen(15)))
}
```

### Deck only

```{r, "current lognormal deck matchup samples plot", fig.width=10.5, fig.height=7.5, warning=FALSE}
plot_samples_wrap(get_matchups(vs_results, current_decks[current_valid]))
```

### Overall

```{r, "current overall matchup samples plot", fig.width=10.5, fig.height=7.5, warning=FALSE, include=TRUE}
plot_matchup_samples(get_matchups(vs_results, current_decks[current_valid], current_players[current_valid]), 2)
```

# Matchup tables {data-orientation=rows data-navmenu="Predictions"}

```{r, "current mean matchups"}
current_deck_matchup_array <- get_matchup_array(vs_results, current_decks[current_valid])
current_matchup_array <- get_matchup_array(vs_results, current_decks[current_valid], current_players[current_valid])

current_deck_matchups <- apply(current_deck_matchup_array, 2:3, mean)
current_matchups <- apply(current_matchup_array, 2:3, mean)
```

```{r, "nondropped mean matchups"}
nondropped_deck_matchup_array <- get_matchup_array(
  vs_results,
  nondropped_decks[nondropped_valid]
)
nondropped_matchup_array <- get_matchup_array(
  vs_results,
  nondropped_decks[nondropped_valid],
  nondropped_players[nondropped_valid]
)

nondropped_deck_matchups <- apply(nondropped_deck_matchup_array, 2:3, mean)
nondropped_matchups <- apply(nondropped_matchup_array, 2:3, mean)
```

### Deck-only

```{r, "current deck matchups"}
kable(reformat_mean_matchup(current_deck_matchups, "D"), digits = 3)
```

### Overall

```{r, "current overall matchups", include=TRUE}
kable(reformat_mean_matchup(current_matchups, "P"), digits = 3)
```

# Nash equilibria for entrants {data-orientation=rows data-navmenu="Predictions"}

Nash equilibrium is not a good indicator of who's most likely to win the tournament, but it's a quick, simple heuristic to find likely contenders. Weights given are averaged over Nash equilibria calculated for each simulation sample (n = 4000).

```{r, "current mean Nash"}
nondropped_deck_nash_samples <- get_nash_equilibria(nondropped_deck_matchup_array)
nondropped_deck_mean_nash <- as.data.table(
  apply(nondropped_deck_nash_samples, 1:2, mean), 
  keep.rownames = "Player"
)[
  ,
  c(.(Player = factor(Player, c("P1", "P2", "Both"))), .SD), 
  .SDcols = dimnames(nondropped_deck_nash_samples)[[2]]
  ]
nondropped_nash_samples <- get_nash_equilibria(nondropped_matchup_array)
nondropped_mean_nash <- as.data.table(
  apply(nondropped_nash_samples, 1:2, mean), 
  keep.rownames = "Player"
)[,
  c(.(Player = factor(Player, c("P1", "P2", "Both"))), .SD), 
  .SDcols = dimnames(nondropped_nash_samples)[[2]]
  ]
```

## Mean Nash win rate {data-height=300}

### Deck-only mean win rate

```{r, "deck mean Nash win"}
kable(print_nash(nondropped_deck_mean_nash), digits = 3)
```

### Overall mean win rate

```{r, "overall mean Nash win"}
kable(print_nash(nondropped_mean_nash), digits = 3)
```

## Mean Nash pick rate {data-height=700}

### Deck-only mean pick distribution

```{r, "deck mean Nash spread"}
kable(reformat_used_nash(nondropped_deck_mean_nash), digits = 3)
```

### Overall mean pick distribution

```{r, "overall mean Nash spread"}
kable(reformat_used_nash(nondropped_mean_nash), digits = 3)
```

# Tournament & evaluation {data-navmenu="Predictions"}

## Plots {data-width=400}

```{r, "current matchup progression"}
current_match_predictions <- current_matches[
  ,
  .(round, round_match_number,
    player1, player2,
    deck1, deck2,
    victor = factor(
      ifelse(
        is.na(victor), "ongoing",
        ifelse(victor == player1, "P1", "P2")
      ),
      levels = c("P1", "ongoing", "P2")
    ),
    `P1 win probability` = diag(current_matchups[player1, player2]))
  ][, c(.SD, .(fairness = 1 - 2*abs(`P1 win probability` - 1/2)))]
```

###

```{r, "plot current matchup progression"}
if (nrow(current_match_predictions) > 0)
  ggplotly(
    ggplot(
      current_match_predictions,
      aes(
        x = round, y = `P1 win probability`,
        colour = victor,
        text = paste0(
          "round: ", round,
          "\nP1: ", paste(player1, deck1),
          "\nP2: ", paste(player2, deck2),
          "\nP1 win probability: ", round(`P1 win probability`, digits = 3),
          "\nfairness: ", round(fairness, digits = 3),
          "\nvictor: ",
          ifelse(
            victor == "P1",
            player1,
            ifelse(victor == "P2", player2, "ongoing")
          )
        )
      )
    ) +
      geom_point() +
      ylim(0, 1) +
      scale_x_discrete(limits = seq.int(max(current_match_predictions$round))) +
      scale_colour_viridis_d(option = "B", drop = FALSE),
    tooltip = c("text")
  )
```

`r if(nrow(current_match_predictions) == 0) "waiting for match results..."`

###

```{r, "plot current fairness progression"}
if (nrow(current_match_predictions) > 0)
  ggplotly(
    ggplot(
      current_match_predictions,
      aes(
        x = round, y = `fairness`,
        colour = victor,
        text = paste0(
          "round: ", round,
          "\nP1: ", paste(player1, deck1),
          "\nP2: ", paste(player2, deck2),
          "\nP1 win probability: ", round(`P1 win probability`, digits = 3),
          "\nfairness: ", round(fairness, digits = 3),
          "\nvictor: ",
          ifelse(
            victor == "P1",
            player1,
            ifelse(victor == "P2", player2, "ongoing")
          )
        )
      )
    ) +
      geom_point() +
      ylim(0, 1) +
      scale_x_discrete(limits = seq.int(max(current_match_predictions$round))) +
      scale_colour_viridis_d(option = "B", drop = FALSE),
    tooltip = c("text")
  )
```

`r if(nrow(current_match_predictions) == 0) "waiting for match results..."`

## Evaluation for normal finished matches {data-width=600}

```{r, "current counts"}
if (nrow(current_match_predictions) > 0) {
current_matches_result_tallies <- finished_current_matches[
  victory == "normal",
  .(P1 = as.factor(player1),
    P2 = as.factor(player2),
    `P1 win` = victor == player1)
  ]
current_matches_counts <- current_matches_result_tallies[
  ,
  .(`P1 wins` = paste(sum(`P1 win`), .N, sep = "/")),
  by = c("P1", "P2")
  ]
}
```

```{r, "current prediction evaluation"}
if (nrow(current_match_predictions) > 0) {
  current_matchups_table <- as.data.table(
    current_matchups,
    keep.rownames = "P1"
  )[,
    c(list(P1 = factor(P1, unique(P1))), .SD),
    .SDcols = setdiff(colnames(current_matchups), "P1")
    ] %>% 
    melt(id.vars = "P1", variable.name = "P2", value.name = "matchup")
  current_lognormal_eval <- current_matchups_table[
    current_matches_counts,
    on = c("P1", "P2")
    ][order(P1, P2)]
}
```

### {data-height=220}

```{r, "current scores"}
if (nrow(current_match_predictions) > 0)
kable(
  current_matchups_table[
    current_matches_result_tallies, on = c("P1", "P2")
    ][,
      .(`prior expected score` = mean(matchup*(1 - matchup)),
        `Brier score` = mean((`P1 win` - matchup)^2))
      ][,
        .(forecast = c("always 5-5", "prior expected score", "model"),
          `Brier score` = c(1/4, `prior expected score`, `Brier score`))],
  digits = 3
)
```

`r if(nrow(current_match_predictions) == 0) "waiting for match results..."`

### {data-height=780}

```{r, "current evaluation table"}
if (nrow(current_match_predictions) > 0) {
  kable(current_lognormal_eval[order(-matchup)], digits = 3)
}
```

`r if(nrow(current_match_predictions) == 0) "waiting for match results..."`
