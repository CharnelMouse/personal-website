---
title: "CAMS20 predictions"
output: 
  flexdashboard::flex_dashboard:
    navbar:
      - {title: "Main Codex page", href: "/project/codex", align: right}
      - {title: "Main site", href: "/", align: right}
    theme: bootstrap
    css: tables.css
    self_contained: no
    lib_dir: libs
author: "Mark Webster"
date: 2020-08-02
---

```{r, "setup", include=FALSE}
current <- "CAMS20"
library(ggplot2)
theme_codex <- theme_dark() +
  theme(panel.border = element_rect(fill = NA, colour = "grey13"),
        plot.background = element_rect(fill = "grey13", colour = "grey13"),
        axis.ticks = element_line(colour = "white"),
        strip.background = element_rect(fill = "grey13", colour = NA),
        legend.background = element_rect(fill = "grey13", colour = NA),
        text = element_text(colour = "white"),
        axis.text = element_text(colour = "white"), 
  )
theme_set(theme_codex)
library(magrittr)
library(data.table)
library(codex)
library(lpSolve)
library(knitr)
library(plotly)
knitr::opts_chunk$set(echo = FALSE)
```

```{r, "read model results"}
vs_results <- readRDS("tidy_current_vs_split.rds")
```

# Entrants {data-navmenu="Data"}

```{r, "current matchups"}
current_players <- decks[tournament == current, player]
current_decks <- decks[tournament == current, deck]
current_entries <- data.table(player = current_players, deck = current_decks, stringsAsFactors = TRUE)
kable(current_entries)
current_valid <- !is.na(current_decks)
```

# Completed matches {data-navmenu="Data"}

```{r, "current matches"}
current_matches <- matches[tournament == current][order(round, round_match_number)]
```

```{r, "finished current matches"}
finished_current_matches <- current_matches[!is.na(victor)]
kable(finished_current_matches[, c("round",
                                   "player1", "player2",
                                   "deck1", "deck2",
                                   "victor", "victory")],
      digits = 3)
```

# Matchup plots {data-orientation=rows data-navmenu="Predictions" .no-mobile}

Colours indicate mean matchup, using the [viridis inferno palette](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html). Vertical lines in each violin plot mark the inner quartiles. Rows are for Player 1, columns are for Player 2. (Currently not shown on mobile devices.)

```{r, "matchup plot with wrap function"}
plot_samples_wrap <- function(matchup_samples) {
  plot_matchup_samples(matchup_samples[, .(P1 = `levels<-`(P1, stringr::str_replace_all(levels(P1), "/", " ")),
                                           P2 = `levels<-`(P2, stringr::str_replace_all(levels(P2), "/", " ")),
                                           prob_matchup, prob_mean)], 2) +
    facet_grid(P1~P2, labeller = labeller(P1 = label_wrap_gen(10), P2 = label_wrap_gen(15)))
}
```

### Deck only

```{r, "current lognormal deck matchup samples plot", fig.width=10.5, fig.height=7.5, warning=FALSE}
plot_samples_wrap(get_matchups(vs_results, current_decks[current_valid]))
```

### Overall

```{r, "current overall matchup samples plot", fig.width=10.5, fig.height=7.5, warning=FALSE, include=FALSE}
plot_matchup_samples(get_matchups(vs_results, current_decks[current_valid], current_players[current_valid]), 2)
```

Hidden until the tournament is finished, to prevent influencing matches.

# Matchup tables {data-orientation=rows data-navmenu="Predictions"}

```{r, "current mean matchups"}
current_deck_matchup_array <- get_matchup_array(vs_results, current_decks[current_valid])
current_matchup_array <- get_matchup_array(vs_results, current_decks[current_valid], current_players[current_valid])

current_deck_matchups <- apply(current_deck_matchup_array, 2:3, mean)
current_matchups <- apply(current_matchup_array, 2:3, mean)
```

### Deck-only

```{r, "current deck matchups"}
kable(reformat_mean_matchup(current_deck_matchups, "D"), digits = 3)
```

### Overall

```{r, "current overall matchups", include=FALSE}
kable(reformat_mean_matchup(current_matchups, "P"), digits = 3)
```

Hidden until the tournament is finished, to prevent influencing matches.

# Nash equilibria for entrants {data-orientation=rows data-navmenu="Predictions"}

Nash equilibrium is not a good indicator of who's most likely to win the tournament, but it's a quick, simple heuristic to find likely contenders. Weights given are averaged over Nash equilibria calculated for each simulation sample (n = 4000).

```{r, "current mean Nash"}
current_deck_nash_samples <- get_nash_equilibria(current_deck_matchup_array)
current_deck_mean_nash <- as.data.table(apply(current_deck_nash_samples, 1:2, mean), 
                                        keep.rownames = "Player")[, c(.(Player = factor(Player, 
                                                                                        c("P1", "P2", "Both"))), 
                                                                      .SD), 
                                                                  .SDcols = dimnames(current_deck_nash_samples)[[2]]]
current_nash_samples <- get_nash_equilibria(current_matchup_array)
current_mean_nash <- as.data.table(apply(current_nash_samples, 1:2, mean), 
                                   keep.rownames = "Player")[, c(.(Player = factor(Player, 
                                                                                   c("P1", "P2", "Both"))), 
                                                                 .SD), 
                                                             .SDcols = dimnames(current_nash_samples)[[2]]]
```

## Mean Nash win rate {data-height=300}

### Deck-only mean win rate

```{r, "deck mean Nash win"}
kable(print_nash(current_deck_mean_nash), digits = 3)
```

### Overall mean win rate

```{r, "overall mean Nash win"}
kable(print_nash(current_mean_nash), digits = 3)
```

## Mean Nash pick rate {data-height=700}

### Deck-only mean pick distribution

```{r, "deck mean Nash spread"}
kable(reformat_used_nash(current_deck_mean_nash), digits = 3)
```

### Overall mean pick distribution

```{r, "overall mean Nash spread"}
kable(reformat_used_nash(current_mean_nash), digits = 3)
```

# Tournament & evaluation {data-navmenu="Predictions"}

## Plots {data-width=400}

```{r, "current matchup progression"}
current_match_predictions <- current_matches[, .(round, round_match_number,
                                                 player1, player2,
                                                 deck1, deck2,
                                                 victor = factor(ifelse(is.na(victor), "ongoing", ifelse(victor == player1, "P1", "P2")),
                                                                 levels = c("P1", "P2", "ongoing")),
                                                 `P1 win probability` = diag(current_matchups[player1, player2]))
                                             ][, c(.SD, .(fairness = 1 - 2*abs(`P1 win probability` - 1/2)))]
```

###

```{r, "plot current matchup progression"}
ggplotly(ggplot(current_match_predictions,
                aes(x = round, y = `P1 win probability`, colour = victor,
                    text = paste0("round: ", round, "\nP1: ", paste(player1, deck1), "\nP2: ", paste(player2, deck2),
                                  "\nP1 win probability: ", round(`P1 win probability`, digits = 3),
                                  "\nfairness: ", round(fairness, digits = 3),
                                  "\nvictor: ",
                                  ifelse(victor == "P1", player1, ifelse(victor == "P2", player2, "ongoing"))))) +
           geom_point() +
           ylim(0, 1) +
           scale_x_discrete(limits = seq.int(max(current_match_predictions$round))) +
           scale_colour_viridis_d(),
         tooltip = c("text"))
```

###

```{r, "plot current fairness progression"}
ggplotly(ggplot(current_match_predictions,
                aes(x = round, y = `fairness`, colour = victor,
                    text = paste0("round: ", round, "\nP1: ", paste(player1, deck1), "\nP2: ", paste(player2, deck2),
                                  "\nP1 win probability: ", round(`P1 win probability`, digits = 3),
                                  "\nfairness: ", round(fairness, digits = 3),
                                  "\nvictor: ",
                                  ifelse(victor == "P1", player1, ifelse(victor == "P2", player2, "ongoing"))))) +
           geom_point() +
           ylim(0, 1) +
           scale_x_discrete(limits = seq.int(max(current_match_predictions$round))) +
           scale_colour_viridis_d(),
         tooltip = c("text"))
```

## Evaluation for normal finished matches {data-width=600}

```{r, "current counts"}
current_matches_result_tallies <- finished_current_matches[victory == "normal",
                                                           .(P1 = as.factor(player1),
                                                             P2 = as.factor(player2),
                                                             `P1 win` = victor == player1)
                                                           ]
current_matches_counts <- current_matches_result_tallies[, .(`P1 wins` = paste(sum(`P1 win`), .N, sep = "/")),
                                                         by = c("P1", "P2")]
```

```{r, "current prediction evaluation"}
current_matchups_table <- as.data.table(current_matchups,
                                        keep.rownames = "P1")[, c(list(P1 = factor(P1, unique(P1))),
                                                                  .SD),
                                                              .SDcols = setdiff(colnames(current_matchups),
                                                                                "P1")] %>% 
  melt(id.vars = "P1", variable.name = "P2", value.name = "matchup")
current_lognormal_eval <- current_matchups_table[current_matches_counts, on = c("P1", "P2")
                                                 ][order(P1, P2)]
```

### {data-height=220}

```{r, "current scores"}
kable(current_matchups_table[current_matches_result_tallies, on = c("P1", "P2")
                             ][, .(`prior expected score` = mean(matchup*(1 - matchup)),
                                   `Brier score` = mean((`P1 win` - matchup)^2))
                               ][, .(forecast = c("always 5-5", "prior expected score", "model"),
                                     `Brier score` = c(1/4, `prior expected score`, `Brier score`))],
      digits = 3)
```

### {data-height=780}

```{r, "current evaluation table"}
kable(current_lognormal_eval[order(-matchup)], digits = 3)
```
